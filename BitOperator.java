public class BitOperator {
	public static void main(String[] args) {
//		反码原码补码
//		位运算跟二进制相结合
		
		System.out.println(2&3);
		
//		推导过程
//		1.先得倒2的补码
//		首先2的原码是 00000000 00000000 00000000 00000010  4个字节（byte），8个bit构成1个字节，每个bit都可以是0或1
//		2的补码是     00000000 00000000 00000000 00000010 正数的原码补码是一样的
//		2.3的补码
//		首先3的原码是 00000000 00000000 00000000 00000011
//		3的补码是     00000000 00000000 00000000 00000011
//		3.计算 按位与 &  2&3 补码运算示意如下
		/*
		  00000000 00000000 00000000 00000010
		  00000000 00000000 00000000 00000011
		  00000000 00000000 00000000 00000010    全部为1结果为1，否则为0
		  得倒了运算后的补码
		  */
//		4.转换为原码 因为是正数，补码原码一样
//		结果就是 00000000 000000000 00000000 00000010
//		就是2
		
		
		
		System.out.println(~-2);
		
//		推导
//		1.先得到-2的补码
//		-2的原码是 10000000 00000000 00000000 00000010
//		负数的补码是反码+1
//		-2的反码是 11111111 11111111 11111111 11111101  反码是原码符号位不变，其他位取反 （0变1，1变0）
//		-2的补码是 11111111 11111111 11111111 11111110
//		2.计算按位取反 ～
//		         00000000 000000000 00000000 00000001
//		得到运算后的补码
//		3.转换为原码显示，因为补码首位为0，则说明是正数，原码补码一致
//		最终结果为1
		
		
		System.out.println(~2);
//		推导
//		1.先得到2的补码 00000000 00000000 00000000 00000010
//		2.计算 按位取反 ～    11111111 11111111 11111111 11111101
//		得到补码，显示需要转换为原码，负数的原码是符号位不变，反码的其他位转换
//		负数的反码等于补码-1
//		3.得到反码     11111111 11111111 11111111 11111100
//		  得倒原码     10000000 00000000 00000000 00000011
//		最终结果为-3
		
		
		System.out.println(2|3);
//		推导
//		1.2的补码
//		首先2的原码是 00000000 00000000 00000000 00000010  4个字节（byte），8个bit构成1个字节，每个bit都可以是0或1
//		2的补码是     00000000 00000000 00000000 00000010 正数的原码补码是一样的
//		2.3的补码
//		首先3的原码是 00000000 00000000 00000000 00000011
//		3的补码是     00000000 00000000 00000000 00000011
//		3.计算 按位或｜　　两位有一个为1，结果为1，否则为0
//		２｜３ 的补码为　　　　 00000000 00000000 000000000 00000011
//		正数原码补码一致 结果为3
		
		
		System.out.println(2^3);
//		推导
//		1.2的补码
//		首先2的原码是 00000000 00000000 00000000 00000010  4个字节（byte），8个bit构成1个字节，每个bit都可以是0或1
//		2的补码是     00000000 00000000 00000000 00000010 正数的原码补码是一样的
//		2.3的补码
//		首先3的原码是 00000000 00000000 00000000 00000011
//		3的补码是     00000000 00000000 00000000 00000011
//		3.计算 按位异或 
//		得到补码 00000000 000000000 00000000 00000001
//		正数原码补码一致，得到结果为1
		
		
		System.out.println(~-5);
//		推导
//		1.-5的补码是 
//		-5的原码：10000000 00000000 00000000 00000101
//		-5的反码：11111111 11111111 11111111 11111010
//		-5的补码：11111111 11111111 11111111 11111011
//		2.计算取反
//		        00000000 000000000 000000000 00000100
//		得到补码 原码一致 结果为4
		
		System.out.println(13&7);
//		推导
//		1.13的补码与原码一致 
//		    00000000 00000000 00000000 00001101
//		2.7的补码与原码一致
//		    00000000 00000000 00000000 00000111
//		3.计算 按位与 得到补码
//		    00000000 00000000 00000000 00000101
//		正数补码原码一致 结果为5
		
		
		System.out.println(5|4);
//		推导
//		1.5的补码与原码一致
//		00000000 00000000 00000000 00000101
//		2.4的补码与原码一致
//		00000000 00000000 00000000 00000100
//		3.计算按位或
//		00000000 00000000 00000000 00000101
//		正数补码原码一致 结果为5
		
		System.out.println(-3^3);
//		推导
//		1.-3的补码
//		-3的原码：10000000 00000000 00000000 00000011
//		-3的反码：11111111 11111111 11111111 11111100
//		-3的补码：11111111 11111111 11111111 11111101
//		2.3的补码
//		首先3的原码是 00000000 00000000 00000000 00000011
//		3的补码是 00000000 00000000 00000000 00000011
//		计算异或
//		得到补码  11111111 11111111 11111111 11111110
//		负数反码等于补码-1 11111111 11111111 11111111 11111101
//		原码   10000000 00000000 00000000 00000010
//		结果为-2
		
		
		
		System.out.println(1 >> 2); //  1/2/2=0
		System.out.println(1 << 2); //  1*2*2=4
		System.out.println(4 << 3); //  4*2*2*2=32
		System.out.println(15 >> 2); //  15/2/2=3
		System.out.println(-1 >> 2);  //为什么结果为-1疑惑？
		System.out.println(-1 << 2);
		
		
		int i = 66;
		System.out.println(++i + i);  //++i 是67 并赋值67给i   结果是67+67=134
		System.out.println(i++ + i);  //i++ 是67+1，i的值是67  结果是68+67=135
		
	}
		
		
	}
		